<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="mingchao.wang">
        <link rel="canonical" href="https://mingchao.wang/002_%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/09_HMM/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Index - 算法工程师笔记</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/obsidian.min.css">
        <link href="../../css/extra.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/django.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/python.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-274394082"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-274394082');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
            <div class="container">
                <a class="navbar-brand" href="../..">算法工程师笔记</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a href="https://github.com/wmc1992/" class="nav-link"><i class="fa fa-github"></i> GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#_1" class="nav-link">隐马尔可夫模型</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_2" class="nav-link">前言</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_3" class="nav-link">一、问题及模型的说明</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#11" class="nav-link">1.1 模型定义</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#12" class="nav-link">1.2 马尔可夫链的性质说明</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_4" class="nav-link">二、前向算法，后向算法，以及给定模型参数后观测序列的概率求解</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#21" class="nav-link">2.1 给定模型参数后观测序列的概率求解</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#22" class="nav-link">2.2 引出前向算法和后向算法的定义</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#23" class="nav-link">2.3 前向算法</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#24" class="nav-link">2.4 后向算法</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_5" class="nav-link">四、模型的预测</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#41" class="nav-link">4.1 近似法</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#42" class="nav-link">4.2 维特比算法原理</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#43" class="nav-link">4.3 维特比算法</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hmmcrf" class="nav-link">五、HMM与CRF比较链接</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">后来补充</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p align="right">[<a href="/k3WiNHrR_no_toc/">隐藏左侧目录栏</a>][<a href="/k3WiNHrR/">显示左侧目录栏</a>]</p>

<h1 id="_1">隐马尔可夫模型<a class="headerlink" href="#_1" title="Permanent link">#</a></h1>
<h2 id="_2">前言<a class="headerlink" href="#_2" title="Permanent link">#</a></h2>
<p>HMM（隐马尔可夫模型）的全部描述分为四部分：</p>
<ul>
<li>问题及模型的说明，包括：模型及符号的说明；马尔可夫链的性质说明</li>
<li>前向算法，后向算法，以及给定模型参数后观测序列的概率求解</li>
<li>模型的学习，主要是无监督学习</li>
<li>模型的预测，即维特比算法</li>
</ul>
<h2 id="_3">一、问题及模型的说明<a class="headerlink" href="#_3" title="Permanent link">#</a></h2>
<h3 id="11">1.1 模型定义<a class="headerlink" href="#11" title="Permanent link">#</a></h3>
<p>如图1所示：</p>
<table>
<thead>
<tr>
<th>图1</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="图1_模型介绍" src="/k3WiNHrR/assets/图1_模型介绍.gif" /></td>
</tr>
</tbody>
</table>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
q &amp;=\{q_0, q_1, q_2, ... ..., q_T\} \\
y &amp;=\{y_0, y_1, y_2, ... ..., y_T\}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
q &=\{q_0, q_1, q_2, ... ..., q_T\} \\
y &=\{y_0, y_1, y_2, ... ..., y_T\}
\end{aligned}
</script>
</div>
<p><span class="arithmatex"><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>为长度为<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>的状态序列；<span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>是对应的长度为<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>的观测序列</p>
<p><span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>为所有可能的状态集合，<span class="arithmatex"><span class="MathJax_Preview">Q = \{Q_1, Q_2, ..., Q_N\}</span><script type="math/tex">Q = \{Q_1, Q_2, ..., Q_N\}</script></span>，可能的状态数为<span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>；
<span class="arithmatex"><span class="MathJax_Preview">Y</span><script type="math/tex">Y</script></span>为所有可能的观测的集合，<span class="arithmatex"><span class="MathJax_Preview">Y = \{Y_1, Y_2, ..., Y_M\}</span><script type="math/tex">Y = \{Y_1, Y_2, ..., Y_M\}</script></span>，可能的观测数为<span class="arithmatex"><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>为状态转移概率矩阵，<span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>中的元素记为<span class="arithmatex"><span class="MathJax_Preview">a_{q_t q_{t+1}}</span><script type="math/tex">a_{q_t q_{t+1}}</script></span>。注意，矩阵<span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>的规模为<span class="arithmatex"><span class="MathJax_Preview">N*N</span><script type="math/tex">N*N</script></span>，它与序列长度<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>无关。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>为发射概率矩阵，<span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>中的元素记为<span class="arithmatex"><span class="MathJax_Preview">b_{q_t y_t}</span><script type="math/tex">b_{q_t y_t}</script></span>，后文为了书写方便，直接记为<span class="arithmatex"><span class="MathJax_Preview">b_{y_t}</span><script type="math/tex">b_{y_t}</script></span>。矩阵<span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>的规模为<span class="arithmatex"><span class="MathJax_Preview">N*M</span><script type="math/tex">N*M</script></span>，同样与序列长度<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>无关。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>为初始 <span class="arithmatex"><span class="MathJax_Preview">t=0</span><script type="math/tex">t=0</script></span> 时刻状态序列中的节点取值概率。</p>
<h3 id="12">1.2 马尔可夫链的性质说明<a class="headerlink" href="#12" title="Permanent link">#</a></h3>
<p>这里主要是两个基本假设，以及由这两个假设衍生的后面推导时使用到的性质，都列在这里。</p>
<p><strong>假设一：</strong>齐次马尔可夫性假设（该假设是对状态序列的假设，即认为当前时刻的状态只与前一时刻有关）</p>
<div class="arithmatex">
<div class="MathJax_Preview">p(q_t|y_0,y_1,...,y_{t-1},q_0,q_1,...,q_{t-1}) = p(q_t|q_{t-1})</div>
<script type="math/tex; mode=display">p(q_t|y_0,y_1,...,y_{t-1},q_0,q_1,...,q_{t-1}) = p(q_t|q_{t-1})</script>
</div>
<p>该条假设用图2所示进行理解，可表述为<span class="arithmatex"><span class="MathJax_Preview">p(q_t|A) = p(q_t|B)</span><script type="math/tex">p(q_t|A) = p(q_t|B)</script></span></p>
<table>
<thead>
<tr>
<th>图2</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="图2" src="/k3WiNHrR/assets/图2.gif" /></td>
</tr>
</tbody>
</table>
<p><strong>假设二：</strong>观测独立性假设（该假设是对观测序列的假设，即认为观测序列中各时刻之间是条件独立的，各时刻的观测值只与对应的状态序列值有关）</p>
<div class="arithmatex">
<div class="MathJax_Preview">p(y_t|y_0,y_1,...,y_{t-1},y_{t+1},..,y_T,p_0,p_1,...,p_T) = p(y_t|p_t)</div>
<script type="math/tex; mode=display">p(y_t|y_0,y_1,...,y_{t-1},y_{t+1},..,y_T,p_0,p_1,...,p_T) = p(y_t|p_t)</script>
</div>
<p>该假设用图3进行理解，可表述为<span class="arithmatex"><span class="MathJax_Preview">p(y_t|A) = p(y_t|B)</span><script type="math/tex">p(y_t|A) = p(y_t|B)</script></span></p>
<table>
<thead>
<tr>
<th>图3</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="图3" src="/k3WiNHrR/assets/图3.gif" /></td>
</tr>
</tbody>
</table>
<p>后续推导过程中会使用到的性质：</p>
<ul>
<li><strong>性质一：</strong> 见图4，给定 <span class="arithmatex"><span class="MathJax_Preview">q_t</span><script type="math/tex">q_t</script></span> 时，红框部分与绿框部分条件独立，即 <span class="arithmatex"><span class="MathJax_Preview">p(AB|q_t)=p(A|q_t)p(B|q_t)</span><script type="math/tex">p(AB|q_t)=p(A|q_t)p(B|q_t)</script></span></li>
</ul>
<table>
<thead>
<tr>
<th>图4</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="图4" src="/k3WiNHrR/assets/图4.gif" /></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>性质二：</strong> 见图5，<span class="arithmatex"><span class="MathJax_Preview">p(A|B) = p(A|C)</span><script type="math/tex">p(A|B) = p(A|C)</script></span>，即给定 <span class="arithmatex"><span class="MathJax_Preview">q_t</span><script type="math/tex">q_t</script></span> 之后，后面的时刻与 <span class="arithmatex"><span class="MathJax_Preview">q_{t-1}</span><script type="math/tex">q_{t-1}</script></span> 无关了</li>
</ul>
<table>
<thead>
<tr>
<th>图5</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="图5" src="/k3WiNHrR/assets/图5.gif" /></td>
</tr>
</tbody>
</table>
<h2 id="_4">二、前向算法，后向算法，以及给定模型参数后观测序列的概率求解<a class="headerlink" href="#_4" title="Permanent link">#</a></h2>
<h3 id="21">2.1 给定模型参数后观测序列的概率求解<a class="headerlink" href="#21" title="Permanent link">#</a></h3>
<p>已知：<span class="arithmatex"><span class="MathJax_Preview">\lambda (\pi、A、B)</span><script type="math/tex">\lambda (\pi、A、B)</script></span>
待求解：<span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
p(y) &amp;= \sum_q p(y, q) \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_0,y_1,...,y_T,q_0,q_1,...,q_T) \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_0,y_1,...,y_T,q_1,...,q_T|q_0)p(q_0) \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_1,y_2,...,y_T,q_1,...,q_T|q_0)p(y_0|q_0)p(q_0) \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_1,y_2,...,y_T,q_1,...,q_T|q_0) \prod^0_{t=0}b_{y_t} \cdot \pi_0 \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_1,y_2,...,y_T,q_2,...,q_T|q_0,q_1)p(q_1|q_0) \prod^0_{t=0}b_{y_t} \cdot \pi_0 \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_2,y_3,...,y_T,q_2,...,q_T|q_1)p(y_1|q_1)p(q_1|q_0) \prod^0_{t=0}b_{y_t} \cdot \pi_0 \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_2,y_3,...,y_T,q_2,...,q_T|q_1) \prod^0_{t=0}a_{q_t q_{t+1}} \prod^1_{t=0}b_{y_t} \cdot \pi_0 \\
&amp;\cdots \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=0} b_{y_t}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
p(y) &= \sum_q p(y, q) \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_0,y_1,...,y_T,q_0,q_1,...,q_T) \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_0,y_1,...,y_T,q_1,...,q_T|q_0)p(q_0) \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_1,y_2,...,y_T,q_1,...,q_T|q_0)p(y_0|q_0)p(q_0) \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_1,y_2,...,y_T,q_1,...,q_T|q_0) \prod^0_{t=0}b_{y_t} \cdot \pi_0 \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_1,y_2,...,y_T,q_2,...,q_T|q_0,q_1)p(q_1|q_0) \prod^0_{t=0}b_{y_t} \cdot \pi_0 \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_2,y_3,...,y_T,q_2,...,q_T|q_1)p(y_1|q_1)p(q_1|q_0) \prod^0_{t=0}b_{y_t} \cdot \pi_0 \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} p(y_2,y_3,...,y_T,q_2,...,q_T|q_1) \prod^0_{t=0}a_{q_t q_{t+1}} \prod^1_{t=0}b_{y_t} \cdot \pi_0 \\
&\cdots \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=0} b_{y_t}
\end{aligned}
</script>
</div>
<blockquote>
<p>在后续所有的公式推导中 <span class="arithmatex"><span class="MathJax_Preview">q_t</span><script type="math/tex">q_t</script></span> 或 <span class="arithmatex"><span class="MathJax_Preview">y_t</span><script type="math/tex">y_t</script></span> 中的 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 表示的是状态序列或观测序列中的某个时刻，每个时刻状态序列中的节点可取值为 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 个，观测序列中的节点可取值为 <span class="arithmatex"><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> 个。<span class="arithmatex"><span class="MathJax_Preview">\sum_{q_t}</span><script type="math/tex">\sum_{q_t}</script></span>表示的是对 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 时刻所有可能的状态取值进行求和。</p>
</blockquote>
<p>该推导过程使用到了<em>马尔可夫链的性质</em>中的<strong>性质一</strong>和<strong>性质二</strong>。</p>
<h3 id="22">2.2 引出前向算法和后向算法的定义<a class="headerlink" href="#22" title="Permanent link">#</a></h3>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
p(q_t|y) &amp;= \frac{p(y|q_t)p(q_t)}{p(y)} \\
&amp;= \frac{p(y_0,y_1,...,y_{t-1},y_t,y_{t+1},...,y_T|q_t)p(q_t)}{p(y)} \\
&amp;= \frac{p(y_0,y_1,...,y_{t-1},y_t|q_t)p(y_{t+1},...,y_T|q_t)p(q_t)}{p(y)} \\
&amp;= \frac{p(y_0,y_1,...,y_{t-1},y_t,q_t)p(y_{t+1},...,y_T|q_t)}{p(y)} \\
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
p(q_t|y) &= \frac{p(y|q_t)p(q_t)}{p(y)} \\
&= \frac{p(y_0,y_1,...,y_{t-1},y_t,y_{t+1},...,y_T|q_t)p(q_t)}{p(y)} \\
&= \frac{p(y_0,y_1,...,y_{t-1},y_t|q_t)p(y_{t+1},...,y_T|q_t)p(q_t)}{p(y)} \\
&= \frac{p(y_0,y_1,...,y_{t-1},y_t,q_t)p(y_{t+1},...,y_T|q_t)}{p(y)} \\
\end{aligned}
</script>
</div>
<p>令：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\alpha(q_t) &amp;= p(y_0,y_1,...,y_{t-1},y_t,q_t) \\
\beta(q_t) &amp;= p(y_{t+1},...,y_T|q_t)
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha(q_t) &= p(y_0,y_1,...,y_{t-1},y_t,q_t) \\
\beta(q_t) &= p(y_{t+1},...,y_T|q_t)
\end{aligned}
</script>
</div>
<h3 id="23">2.3 前向算法<a class="headerlink" href="#23" title="Permanent link">#</a></h3>
<h4 id="231-alphaq_talphaq_t">2.3.1 <span class="arithmatex"><span class="MathJax_Preview">\alpha(q_t)</span><script type="math/tex">\alpha(q_t)</script></span>的递推公式<a class="headerlink" href="#231-alphaq_talphaq_t" title="Permanent link">#</a></h4>
<p>由前述推导可知 <span class="arithmatex"><span class="MathJax_Preview">\alpha(q_t) = p(y_0,y_1,...,y_{t-1},y_t,q_t)</span><script type="math/tex">\alpha(q_t) = p(y_0,y_1,...,y_{t-1},y_t,q_t)</script></span>，则有 <span class="arithmatex"><span class="MathJax_Preview">\alpha(q_{t+1}) = p(y_0,y_1,...,y_{t-1},y_t,y_{t+1},q_{t+1})</span><script type="math/tex">\alpha(q_{t+1}) = p(y_0,y_1,...,y_{t-1},y_t,y_{t+1},q_{t+1})</script></span> 对 <span class="arithmatex"><span class="MathJax_Preview">\alpha(q_{t+1})</span><script type="math/tex">\alpha(q_{t+1})</script></span> 进行推导，看能否得出特殊的性质。</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\alpha(q_{t+1}) &amp;= p(y_0,y_1,...,y_{t-1},y_t,y_{t+1},q_{t+1}) \\
&amp;= p(y_0,y_1,...,y_{t-1},y_t,y_{t+1}|q_{t+1})p(q_{t+1}) \\
&amp;= p(y_0,y_1,...,y_{t-1},y_t|q_{t+1})p(y_{t+1}|q_{t+1})p(q_{t+1}) \\
&amp;= p(y_0,y_1,...,y_{t-1},y_t,q_{t+1})p(y_{t+1}|q_{t+1}) \\
&amp;= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t,q_t,q_{t+1})p(y_{t+1}|q_{t+1}) \\
&amp;= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t,q_{t+1}|q_t)p(q_t)p(y_{t+1}|q_{t+1}) \\
&amp;= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t|q_t)p(q_{t+1}|q_t)p(q_t)p(y_{t+1}|q_{t+1}) \\
&amp;= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t,q_t)p(q_{t+1}|q_t)p(y_{t+1}|q_{t+1}) \\
&amp;= \sum_{q_t} \alpha(q_t) a_{q_t q_{t+1}} b_{y_{t+1}}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha(q_{t+1}) &= p(y_0,y_1,...,y_{t-1},y_t,y_{t+1},q_{t+1}) \\
&= p(y_0,y_1,...,y_{t-1},y_t,y_{t+1}|q_{t+1})p(q_{t+1}) \\
&= p(y_0,y_1,...,y_{t-1},y_t|q_{t+1})p(y_{t+1}|q_{t+1})p(q_{t+1}) \\
&= p(y_0,y_1,...,y_{t-1},y_t,q_{t+1})p(y_{t+1}|q_{t+1}) \\
&= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t,q_t,q_{t+1})p(y_{t+1}|q_{t+1}) \\
&= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t,q_{t+1}|q_t)p(q_t)p(y_{t+1}|q_{t+1}) \\
&= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t|q_t)p(q_{t+1}|q_t)p(q_t)p(y_{t+1}|q_{t+1}) \\
&= \sum_{q_t} p(y_0,y_1,...,y_{t-1},y_t,q_t)p(q_{t+1}|q_t)p(y_{t+1}|q_{t+1}) \\
&= \sum_{q_t} \alpha(q_t) a_{q_t q_{t+1}} b_{y_{t+1}}
\end{aligned}
</script>
</div>
<p>得出了递推公式，再看一下首项：</p>
<div class="arithmatex">
<div class="MathJax_Preview">\alpha(q_0) = p(y_0,q_0) = p(y_0|q_0)p(q_0) = \sum_{q_0} \pi_0 b_{y_0}</div>
<script type="math/tex; mode=display">\alpha(q_0) = p(y_0,q_0) = p(y_0|q_0)p(q_0) = \sum_{q_0} \pi_0 b_{y_0}</script>
</div>
<p>整理如下：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{cases}
\alpha(q_0) = \sum_{q_0} \pi_0 b_{y_0} \\
\alpha(q_{t+1}) = \sum_{q_t} \alpha(q_t) a_{q_t q_{t+1}} b_{y_{t+1}}
\end{cases}
</div>
<script type="math/tex; mode=display">
\begin{cases}
\alpha(q_0) = \sum_{q_0} \pi_0 b_{y_0} \\
\alpha(q_{t+1}) = \sum_{q_t} \alpha(q_t) a_{q_t q_{t+1}} b_{y_{t+1}}
\end{cases}
</script>
</div>
<h4 id="232-pypy">2.3.2 前向算法求解<span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span><a class="headerlink" href="#232-pypy" title="Permanent link">#</a></h4>
<p>先列出 <span class="arithmatex"><span class="MathJax_Preview">\alpha(q_t)</span><script type="math/tex">\alpha(q_t)</script></span> 的前几项：</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\alpha(q_0) = \sum_{q_0} \pi_0 b_{y_0}</span><script type="math/tex">\alpha(q_0) = \sum_{q_0} \pi_0 b_{y_0}</script></span>
<span class="arithmatex"><span class="MathJax_Preview">\alpha(q_1) = \sum_{q_1} \alpha(q_0) a_{q_0 q_1} b_{y_1}</span><script type="math/tex">\alpha(q_1) = \sum_{q_1} \alpha(q_0) a_{q_0 q_1} b_{y_1}</script></span>
<span class="arithmatex"><span class="MathJax_Preview">\alpha(q_2) = \sum_{q_2} \alpha(q_1) a_{q_1 q_2} b_{y_2}</span><script type="math/tex">\alpha(q_2) = \sum_{q_2} \alpha(q_1) a_{q_1 q_2} b_{y_2}</script></span>
<span class="arithmatex"><span class="MathJax_Preview">\alpha(q_3) = \sum_{q_3} \alpha(q_2) a_{q_2 q_3} b_{y_3}</span><script type="math/tex">\alpha(q_3) = \sum_{q_3} \alpha(q_2) a_{q_2 q_3} b_{y_3}</script></span>
<span class="arithmatex"><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span></p>
<p>在 <strong>给定<span class="arithmatex"><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>、<span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>、<span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>，求解 <span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span></strong> 部分中已经求出 <span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span>，则：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
p(y) &amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=0} b_{y_t} \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 b_{y_0} \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=1} b_{y_t} \\
&amp;= \sum_{q_1}\sum_{q_2} \cdots \sum_{q_T} \alpha(q_0) \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=1} b_{y_t} \\
&amp;= \sum_{q_1}\sum_{q_2} \cdots \sum_{q_T} \alpha(q_0) a_{q_0 q_1} b_{y_1} \prod^{T-1}_{t=1}a_{q_t q_{t+1}} \prod^T_{t=2} b_{y_t} \\
&amp;= \sum_{q_2}\sum_{q_3} \cdots \sum_{q_T} \alpha(q_1) \prod^{T-1}_{t=1}a_{q_t q_{t+1}} \prod^T_{t=2} b_{y_t} \\
&amp;\cdots \\
&amp;= \sum_{q_T} \alpha(q_T)
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
p(y) &= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=0} b_{y_t} \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 b_{y_0} \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=1} b_{y_t} \\
&= \sum_{q_1}\sum_{q_2} \cdots \sum_{q_T} \alpha(q_0) \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=1} b_{y_t} \\
&= \sum_{q_1}\sum_{q_2} \cdots \sum_{q_T} \alpha(q_0) a_{q_0 q_1} b_{y_1} \prod^{T-1}_{t=1}a_{q_t q_{t+1}} \prod^T_{t=2} b_{y_t} \\
&= \sum_{q_2}\sum_{q_3} \cdots \sum_{q_T} \alpha(q_1) \prod^{T-1}_{t=1}a_{q_t q_{t+1}} \prod^T_{t=2} b_{y_t} \\
&\cdots \\
&= \sum_{q_T} \alpha(q_T)
\end{aligned}
</script>
</div>
<p>即 <span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span> 可由 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> 进行求解。</p>
<h3 id="24">2.4 后向算法<a class="headerlink" href="#24" title="Permanent link">#</a></h3>
<h4 id="241-betaq_tbetaq_t">2.4.1 <span class="arithmatex"><span class="MathJax_Preview">\beta(q_t)</span><script type="math/tex">\beta(q_t)</script></span>的递推公式<a class="headerlink" href="#241-betaq_tbetaq_t" title="Permanent link">#</a></h4>
<p>由前述推导有 <span class="arithmatex"><span class="MathJax_Preview">\beta(q_t) = p(y_{t+1},y_{t+2},...,y_T|q_t)</span><script type="math/tex">\beta(q_t) = p(y_{t+1},y_{t+2},...,y_T|q_t)</script></span>，则有 <span class="arithmatex"><span class="MathJax_Preview">\beta(q_{t+1}) = p(y_{t+2},y_{t+3},...,y_T|q_{t+1})</span><script type="math/tex">\beta(q_{t+1}) = p(y_{t+2},y_{t+3},...,y_T|q_{t+1})</script></span>，下面对 <span class="arithmatex"><span class="MathJax_Preview">\beta(q_t)</span><script type="math/tex">\beta(q_t)</script></span> 进行推导。</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\beta(q_t) &amp;= p(y_{t+1},y_{t+2},...,y_T|q_t) \\
&amp;= \sum_{q_{t+1}} p(y_{t+1},y_{t+2},...,y_T,q_{t+1}|q_t) \\
&amp;= \sum_{q_{t+1}} p(y_{t+1},y_{t+2},...,y_T|q_t,q_{t+1})p(q_{t+1}|q_t) \\
&amp;= \sum_{q_{t+1}} p(y_{t+1},y_{t+2},...,y_T|q_{t+1})p(q_{t+1}|q_t) \\
&amp;= \sum_{q_{t+1}} p(y_{t+2},...,y_T|q_{t+1})p(y_{t+1}|q_{t+1})p(q_{t+1}|q_t) \\
&amp;= \sum_{q_{t+1}} \beta(q_{t+1}) a_{q_t q_{t+1}} b_{y_{t+1}}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\beta(q_t) &= p(y_{t+1},y_{t+2},...,y_T|q_t) \\
&= \sum_{q_{t+1}} p(y_{t+1},y_{t+2},...,y_T,q_{t+1}|q_t) \\
&= \sum_{q_{t+1}} p(y_{t+1},y_{t+2},...,y_T|q_t,q_{t+1})p(q_{t+1}|q_t) \\
&= \sum_{q_{t+1}} p(y_{t+1},y_{t+2},...,y_T|q_{t+1})p(q_{t+1}|q_t) \\
&= \sum_{q_{t+1}} p(y_{t+2},...,y_T|q_{t+1})p(y_{t+1}|q_{t+1})p(q_{t+1}|q_t) \\
&= \sum_{q_{t+1}} \beta(q_{t+1}) a_{q_t q_{t+1}} b_{y_{t+1}}
\end{aligned}
</script>
</div>
<p>得到地推公式，接下来求首项，由于是从后向前递推，所以首项是 <span class="arithmatex"><span class="MathJax_Preview">\beta(q_{T-1})</span><script type="math/tex">\beta(q_{T-1})</script></span>：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\beta(q_{T-1}) &amp;= p(y_T|q_{T-1}) \\
&amp;= \sum_{q_T} p(y_T,q_{T}|q_{T-1}) \\
&amp;= \sum_{q_T} p(y_T|q_{T-1},q_{T})p(q_T|q_{T-1}) \\
&amp;= \sum_{q_T} p(y_T|q_{T})p(q_T|q_{T-1}) \\
&amp;= \sum_{q_T} a_{q_{T-1} q_T} b_{y_T}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\beta(q_{T-1}) &= p(y_T|q_{T-1}) \\
&= \sum_{q_T} p(y_T,q_{T}|q_{T-1}) \\
&= \sum_{q_T} p(y_T|q_{T-1},q_{T})p(q_T|q_{T-1}) \\
&= \sum_{q_T} p(y_T|q_{T})p(q_T|q_{T-1}) \\
&= \sum_{q_T} a_{q_{T-1} q_T} b_{y_T}
\end{aligned}
</script>
</div>
<h4 id="242-pypy">2.4.2 后向算法求解<span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span><a class="headerlink" href="#242-pypy" title="Permanent link">#</a></h4>
<p>先列出 <span class="arithmatex"><span class="MathJax_Preview">\beta(q_t)</span><script type="math/tex">\beta(q_t)</script></span> 的前几项：</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\beta(q_{T-1}) = \sum_{q_T} a_{q_{T-1} q_T} b_{y_T}</span><script type="math/tex">\beta(q_{T-1}) = \sum_{q_T} a_{q_{T-1} q_T} b_{y_T}</script></span></p>
<p><span class="arithmatex"><span class="MathJax_Preview">\beta(q_{T-2}) = \sum_{q_{T-1}} \beta(q_{T-1}) a_{q_{T-2} q_{T-1}} b_{y_{T-1}}</span><script type="math/tex">\beta(q_{T-2}) = \sum_{q_{T-1}} \beta(q_{T-1}) a_{q_{T-2} q_{T-1}} b_{y_{T-1}}</script></span></p>
<p><span class="arithmatex"><span class="MathJax_Preview">\beta(q_{T-3}) = \sum_{q_{T-2}} \beta(q_{T-2}) a_{q_{T-3} q_{T-2}} b_{y_{T-2}}</span><script type="math/tex">\beta(q_{T-3}) = \sum_{q_{T-2}} \beta(q_{T-2}) a_{q_{T-3} q_{T-2}} b_{y_{T-2}}</script></span></p>
<p><span class="arithmatex"><span class="MathJax_Preview">\beta(q_{T-4}) = \sum_{q_{T-3}} \beta(q_{T-3}) a_{q_{T-4} q_{T-3}} b_{y_{T-3}}</span><script type="math/tex">\beta(q_{T-4}) = \sum_{q_{T-3}} \beta(q_{T-3}) a_{q_{T-4} q_{T-3}} b_{y_{T-3}}</script></span></p>
<p><span class="arithmatex"><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span></p>
<p>在 <strong>给定<span class="arithmatex"><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>、<span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>、<span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>，求解 <span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span></strong> 部分中已经求出 <span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span>，则：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
p(y) &amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=0} b_{y_t} \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 a_{q_{T-1} q_T} b_{y_T} \prod^{T-2}_{t=0}a_{q_t q_{t+1}} \prod^{T-1}_{t=0} b_{y_t} \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_{T-1}} \pi_0 \beta(q_{T-1}) \prod^{T-2}_{t=0}a_{q_t q_{t+1}} \prod^{T-1}_{t=0} b_{y_t} \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_{T-1}} \pi_0 \beta(q_{T-1}) a_{q_{T-2} q_{T-1}} b_{y_{T-1}} \prod^{T-3}_{t=0}a_{q_t q_{t+1}} \prod^{T-2}_{t=0} b_{y_t} \\
&amp;= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_{T-1}} \pi_0 \beta(q_{T-2}) \prod^{T-3}_{t=0}a_{q_t q_{t+1}} \prod^{T-2}_{t=0} b_{y_t} \\
&amp;\cdots \\
&amp;= \sum_{q_0} \pi_0 \beta(q_0) b(y_0)
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
p(y) &= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 \prod^{T-1}_{t=0}a_{q_t q_{t+1}} \prod^T_{t=0} b_{y_t} \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_T} \pi_0 a_{q_{T-1} q_T} b_{y_T} \prod^{T-2}_{t=0}a_{q_t q_{t+1}} \prod^{T-1}_{t=0} b_{y_t} \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_{T-1}} \pi_0 \beta(q_{T-1}) \prod^{T-2}_{t=0}a_{q_t q_{t+1}} \prod^{T-1}_{t=0} b_{y_t} \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_{T-1}} \pi_0 \beta(q_{T-1}) a_{q_{T-2} q_{T-1}} b_{y_{T-1}} \prod^{T-3}_{t=0}a_{q_t q_{t+1}} \prod^{T-2}_{t=0} b_{y_t} \\
&= \sum_{q_0}\sum_{q_1} \cdots \sum_{q_{T-1}} \pi_0 \beta(q_{T-2}) \prod^{T-3}_{t=0}a_{q_t q_{t+1}} \prod^{T-2}_{t=0} b_{y_t} \\
&\cdots \\
&= \sum_{q_0} \pi_0 \beta(q_0) b(y_0)
\end{aligned}
</script>
</div>
<p>即 <span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span> 可以由 <span class="arithmatex"><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> 求解。</p>
<h2 id="_5">四、模型的预测<a class="headerlink" href="#_5" title="Permanent link">#</a></h2>
<p>在解决模型的预测问题时，已知条件为：<span class="arithmatex"><span class="MathJax_Preview">\lambda (\pi、A、B)</span><script type="math/tex">\lambda (\pi、A、B)</script></span>、<span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>；要求解的问题是：求解使得联合概率<span class="arithmatex"><span class="MathJax_Preview">p(y)</span><script type="math/tex">p(y)</script></span>最大的状态序列<span class="arithmatex"><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>。</p>
<h3 id="41">4.1 近似法<a class="headerlink" href="#41" title="Permanent link">#</a></h3>
<p>在引出前向算法和后向算法的定义时，已经求得了<span class="arithmatex"><span class="MathJax_Preview">p(q_t|y)</span><script type="math/tex">p(q_t|y)</script></span>，用该方法求出所有时刻的状态序列取值，作为整个序列的最优解。</p>
<p>优缺点：</p>
<ul>
<li>该方法只是近似，每个时刻的最优解合起来不一定是整个序列的最优解</li>
<li>但是该方法简单</li>
</ul>
<h3 id="42">4.2 维特比算法原理<a class="headerlink" href="#42" title="Permanent link">#</a></h3>
<h4 id="421">4.2.1 动态规划的条件<a class="headerlink" href="#421" title="Permanent link">#</a></h4>
<ol>
<li>原问题可以划分为子问题</li>
<li>能证明原问题的最优解是由子问题的最优解组成的</li>
</ol>
<p>综上两条：动态规划主要是要找到最优子结构</p>
<h4 id="422">4.2.2 动态规划的证明<a class="headerlink" href="#422" title="Permanent link">#</a></h4>
<ul>
<li>将整个路径分为三个时刻，分别为：<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻、<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻、<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻，如果从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻有一条最优路径，并且在<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻的取值为<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>。那么这条最优路径在<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻的这部分路径，必然是从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻，并且<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻取值为<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>时的所有路径中最优的。
<strong>证明-反证法：</strong>
如果不是最优的，那么在<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻取值为<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>时，从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻之间必然有一条更优的路径存在。那么将这条更优的路径与从<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻之间的那部分路径连接起来，会得到一条从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻的更优的路径，这和初始条件矛盾。</li>
<li>用下图进行说明：总共三个时刻，<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻、<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻、<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻，并且在<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻取值为<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>。假设<code>路径a+路径b</code>是从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻的最优路径，那么<code>路径a</code>必然是从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻的最优路径，如果不是的话，那么从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻必然存在一条<code>路径a'</code>相比于<code>路径a</code>更优，那么<code>路径a'+路径b</code>是从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻比<code>路径a+路径b</code>更优的路径，矛盾。</li>
</ul>
<p><img alt="维特比算法证明图" src="/k3WiNHrR/assets/维特比算法证明图.png" /></p>
<blockquote>
<p>《统计学习方法》中在反正法时是证明的后面一段即从<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>时刻这部分，不知道为何这么证明，因为我觉得维特比算法中的最优子结构是从前向后，即由<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻求解<span class="arithmatex"><span class="MathJax_Preview">t+1</span><script type="math/tex">t+1</script></span>时刻，所以应该证明从<span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻这部分。</p>
</blockquote>
<h3 id="43">4.3 维特比算法<a class="headerlink" href="#43" title="Permanent link">#</a></h3>
<h4 id="431">4.3.1 求解最优路径对应的概率<a class="headerlink" href="#431" title="Permanent link">#</a></h4>
<p>定义：</p>
<div class="arithmatex">
<div class="MathJax_Preview">\delta_t(Q_i) = \max_{q_0,q_1,...,q_{t-1}} p(y_0, y_1, ..., y_t, q_0, q_1, ..., q_{t-1}, q_t=Q_i)</div>
<script type="math/tex; mode=display">\delta_t(Q_i) = \max_{q_0,q_1,...,q_{t-1}} p(y_0, y_1, ..., y_t, q_0, q_1, ..., q_{t-1}, q_t=Q_i)</script>
</div>
<p>详细解释一下该定义中各部分的含义：</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\delta_t(Q_i)</span><script type="math/tex">\delta_t(Q_i)</script></span>中右下角的<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>表示状态序列中的<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\delta_t(Q_i)</span><script type="math/tex">\delta_t(Q_i)</script></span>括号中的<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>表示状态序列中<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻的节点的取值为<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span></li>
<li>这个符号整体的含义就是已知观测序列<span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>，已知状态序列的<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻取值为<span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>，任意选取状态序列<span class="arithmatex"><span class="MathJax_Preview">q_1</span><script type="math/tex">q_1</script></span>到<span class="arithmatex"><span class="MathJax_Preview">q_{t-1}</span><script type="math/tex">q_{t-1}</script></span>的取值，使得联合概率<span class="arithmatex"><span class="MathJax_Preview">p(y_0, y_1, ..., y_t, q_0, q_1, ..., q_{t-1}, q_t=Q_i)</span><script type="math/tex">p(y_0, y_1, ..., y_t, q_0, q_1, ..., q_{t-1}, q_t=Q_i)</script></span>取最大值时该联合概率的值</li>
<li>在定义中：<span class="arithmatex"><span class="MathJax_Preview">y_0, y_1, ..., y_t</span><script type="math/tex">y_0, y_1, ..., y_t</script></span>是已知条件，是定值；<span class="arithmatex"><span class="MathJax_Preview">q_t=Q_i</span><script type="math/tex">q_t=Q_i</script></span>也是定值；<span class="arithmatex"><span class="MathJax_Preview">q_0, q_1, ..., q_{t-1}</span><script type="math/tex">q_0, q_1, ..., q_{t-1}</script></span>是待求解的变量<blockquote>
<p><span class="arithmatex"><span class="MathJax_Preview">\delta_t(Q_i)</span><script type="math/tex">\delta_t(Q_i)</script></span>就是该问题的最优子结构</p>
</blockquote>
</li>
</ul>
<p>对<span class="arithmatex"><span class="MathJax_Preview">\delta_{t+1}(Q_j)</span><script type="math/tex">\delta_{t+1}(Q_j)</script></span>进行推导有：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\delta_{t+1}(Q_j) &amp;= \max_{q_0,q_1,...,q_t} p(y_0, y_1, ..., y_t, y_{t+1}, q_0, q_1, ..., q_t, q_{t+1}=Q_j) \\
&amp;= \max_{q_t} \delta_t(q_t) a_{q_tq_{t+1} b_{y_{t+1}}} \\
&amp; 其中 q_t = Q_1, Q_2, ..., Q_N
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\delta_{t+1}(Q_j) &= \max_{q_0,q_1,...,q_t} p(y_0, y_1, ..., y_t, y_{t+1}, q_0, q_1, ..., q_t, q_{t+1}=Q_j) \\
&= \max_{q_t} \delta_t(q_t) a_{q_tq_{t+1} b_{y_{t+1}}} \\
& 其中 q_t = Q_1, Q_2, ..., Q_N
\end{aligned}
</script>
</div>
<p>也就求出了递推公式，从<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻到<span class="arithmatex"><span class="MathJax_Preview">t+1</span><script type="math/tex">t+1</script></span>时刻，总共要计算<span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>个值。所以总的时间复杂度为<span class="arithmatex"><span class="MathJax_Preview">O(TN)</span><script type="math/tex">O(TN)</script></span></p>
<p>由定义可知，求出<span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>个<span class="arithmatex"><span class="MathJax_Preview">\delta_T(Q_i)</span><script type="math/tex">\delta_T(Q_i)</script></span>，最大的那个值就是整个状态序列最可能的取值对应的概率。但这只是一个最大概率值，还要求出这个最优路径具体是哪条路径。</p>
<h4 id="432">4.3.2 求解最优路径<a class="headerlink" href="#432" title="Permanent link">#</a></h4>
<p>定义：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\psi_{t+1}(Q_j) &amp;= \text{arg} \delta_{t+1}(Q_j) \\
&amp;= \text{argmax}_{q_t} \delta_t(q_t) a_{q_tq_{t+1}} b_{y_{t+1}} \\
&amp;= \text{argmax}_{q_t} \delta_t(q_t) a_{q_tq_{t+1}}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\psi_{t+1}(Q_j) &= \text{arg} \delta_{t+1}(Q_j) \\
&= \text{argmax}_{q_t} \delta_t(q_t) a_{q_tq_{t+1}} b_{y_{t+1}} \\
&= \text{argmax}_{q_t} \delta_t(q_t) a_{q_tq_{t+1}}
\end{aligned}
</script>
</div>
<p>详细解释一下该定义的含义：</p>
<ul>
<li>在<span class="arithmatex"><span class="MathJax_Preview">t+1</span><script type="math/tex">t+1</script></span>时刻取值为定值<span class="arithmatex"><span class="MathJax_Preview">Q_j</span><script type="math/tex">Q_j</script></span></li>
<li>在<span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>时刻的取值为待求解变量，<span class="arithmatex"><span class="MathJax_Preview">q_t</span><script type="math/tex">q_t</script></span>可取的值为<span class="arithmatex"><span class="MathJax_Preview">Q_1,Q_2,...,Q_N</span><script type="math/tex">Q_1,Q_2,...,Q_N</script></span></li>
<li><span class="arithmatex"><span class="MathJax_Preview">\psi_{t+1}(Q_j)</span><script type="math/tex">\psi_{t+1}(Q_j)</script></span>的含义为：求解<span class="arithmatex"><span class="MathJax_Preview">t+1</span><script type="math/tex">t+1</script></span>时刻取值为<span class="arithmatex"><span class="MathJax_Preview">Q_j</span><script type="math/tex">Q_j</script></span>时，使得路径最优的<span class="arithmatex"><span class="MathJax_Preview">q_t</span><script type="math/tex">q_t</script></span>的取值</li>
<li>在上面的公式化简过程中，<span class="arithmatex"><span class="MathJax_Preview">b_{y_{t+1}}</span><script type="math/tex">b_{y_{t+1}}</script></span>与变量<span class="arithmatex"><span class="MathJax_Preview">q_t</span><script type="math/tex">q_t</script></span>无关，所以可以直接去掉</li>
</ul>
<p>这样就可以从后向前找到每个时刻的最优取值。</p>
<h4 id="433">4.3.3 算法流程<a class="headerlink" href="#433" title="Permanent link">#</a></h4>
<p>略</p>
<h2 id="hmmcrf">五、HMM与CRF比较链接<a class="headerlink" href="#hmmcrf" title="Permanent link">#</a></h2>
<p>条件随机场（CRF）和隐马尔可夫模型（HMM）最大区别在哪里？CRF的全局最优体现在哪里？ - 知乎用户的回答 - 知乎</p>
<p><a href="https://www.zhihu.com/question/53458773/answer/169987204">https://www.zhihu.com/question/53458773/answer/169987204</a></p>
<p>标注偏置问题(Label Bias Problem)和HMM、MEMM、CRF模型比较</p>
<p><a href="https://blog.csdn.net/lskyne/article/details/8669301">https://blog.csdn.net/lskyne/article/details/8669301</a></p>
<h2 id="_6">后来补充<a class="headerlink" href="#_6" title="Permanent link">#</a></h2>
<h4 id="hmm">HMM的整体理解<a class="headerlink" href="#hmm" title="Permanent link">#</a></h4>
<p>q是状态序列
y是观测序列</p>
<p><strong>状态序列的概率</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">p(q)</div>
<script type="math/tex; mode=display">p(q)</script>
</div>
<p><strong>观测序列的条件概率</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">p(y|q)</div>
<script type="math/tex; mode=display">p(y|q)</script>
</div>
<p><strong>状态序列和观测序列的联合概率</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
p(q, y; \lambda) &amp;= p(y|q) \cdot p(q) \\
&amp;= \pi a_{q_1q_2} a_{q_2q_3} ... a_{q_{T-1}q_T} b_{y_1} b_{y_2} ... b_{y_T}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
p(q, y; \lambda) &= p(y|q) \cdot p(q) \\
&= \pi a_{q_1q_2} a_{q_2q_3} ... a_{q_{T-1}q_T} b_{y_1} b_{y_2} ... b_{y_T}
\end{aligned}
</script>
</div>
<p><strong>观测序列的概率</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
p(y) &amp;= \sum_q p(q,y) \\
&amp;= \sum_{q_1} \sum_{q_2} ... \sum_{q_T} p(q_1, q_2, ..., q_T, y; \lambda)
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
p(y) &= \sum_q p(q,y) \\
&= \sum_{q_1} \sum_{q_2} ... \sum_{q_T} p(q_1, q_2, ..., q_T, y; \lambda)
\end{aligned}
</script>
</div>
<p><strong>预测问题</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">p(q|y) = \frac{p(q,y)}{p(y)} = \frac{p(q|y)p(y)}{p(y)}</div>
<script type="math/tex; mode=display">p(q|y) = \frac{p(q,y)}{p(y)} = \frac{p(q|y)p(y)}{p(y)}</script>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021 Microsoft Research;<a href="https://beian.miit.gov.cn/">备案号：京ICP备2022025323号-1</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../mathjax-config.js" defer></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
